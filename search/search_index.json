{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ignition_vs_gazebo A collection of tests between gazebo and ignition. For a detailed analysis, see my artical comparing ignition and gazebo . Quickstart All tests are located under the tests directory. Each test has a standalone script to launch the simulator. Simply run ./start_gazebo.sh or ./start_ign.sh to launch the test with the desired simulator. Test setup Tests are created using xacro . This ensures that the same properties are used in both simulators. The SDF also sets several GUI properties, which are not compatible between programs. A separate macro was created for each simulator and included in its respective test. Development Environment VSCode Container The test setup includes a VSCode container IDE, which pre-installs gazebo 11 and ignition citadel. If you're on a Linux system, the scripts will launch the respective simulation (including Gazebo GUI). Local If you wish to run the tests natively instead, you'll need to have Gazebo and Ignition installed. Gazebo 11 Ignition Citadel","title":"ignition_vs_gazebo"},{"location":"#ignition_vs_gazebo","text":"A collection of tests between gazebo and ignition. For a detailed analysis, see my artical comparing ignition and gazebo .","title":"ignition_vs_gazebo"},{"location":"#quickstart","text":"All tests are located under the tests directory. Each test has a standalone script to launch the simulator. Simply run ./start_gazebo.sh or ./start_ign.sh to launch the test with the desired simulator.","title":"Quickstart"},{"location":"#test-setup","text":"Tests are created using xacro . This ensures that the same properties are used in both simulators. The SDF also sets several GUI properties, which are not compatible between programs. A separate macro was created for each simulator and included in its respective test.","title":"Test setup"},{"location":"#development-environment","text":"","title":"Development Environment"},{"location":"#vscode-container","text":"The test setup includes a VSCode container IDE, which pre-installs gazebo 11 and ignition citadel. If you're on a Linux system, the scripts will launch the respective simulation (including Gazebo GUI).","title":"VSCode Container"},{"location":"#local","text":"If you wish to run the tests natively instead, you'll need to have Gazebo and Ignition installed. Gazebo 11 Ignition Citadel","title":"Local"},{"location":"tests/bounce/","text":"Bounce Bounce is the rebound or reflection after striking a surface (such as the ground). In the simulation, this is represented by the restitution_coefficient . To model bounce in Gazebo, you need to set 3 parameters in the SDF. restitution_coefficient [0,1] Where 0 is no bounce, and 1 is pure bounce threshold The penetration threshold needed to apply restitution force max_vel The maximum velocity that the restitution force can cause. A restitution_coefficient must be set on both collision surfaces. For balls to achieve infinite bounce with the ground in this simulation, the ground was given a restitution_coefficient=1 Example code snippet <link> ... <collision> ... <surface> <bounce> <restitution_coefficient> 1 </restitution_coefficient> <threshold> 0 </threshold> </bounce> <friction> <ode/> </friction> <contact> <ode> <max_vel> 1000 </max_vel> </ode> </contact> </surface> </collision> </link> Comparison Gazebo | Ignition with restitution coefficient ranging from 1 to 0 in 0.1 increments. Ignition does not currently model bounce.","title":"Bounce"},{"location":"tests/bounce/#bounce","text":"Bounce is the rebound or reflection after striking a surface (such as the ground). In the simulation, this is represented by the restitution_coefficient . To model bounce in Gazebo, you need to set 3 parameters in the SDF. restitution_coefficient [0,1] Where 0 is no bounce, and 1 is pure bounce threshold The penetration threshold needed to apply restitution force max_vel The maximum velocity that the restitution force can cause. A restitution_coefficient must be set on both collision surfaces. For balls to achieve infinite bounce with the ground in this simulation, the ground was given a restitution_coefficient=1","title":"Bounce"},{"location":"tests/bounce/#example-code-snippet","text":"<link> ... <collision> ... <surface> <bounce> <restitution_coefficient> 1 </restitution_coefficient> <threshold> 0 </threshold> </bounce> <friction> <ode/> </friction> <contact> <ode> <max_vel> 1000 </max_vel> </ode> </contact> </surface> </collision> </link>","title":"Example code snippet"},{"location":"tests/bounce/#comparison","text":"Gazebo | Ignition with restitution coefficient ranging from 1 to 0 in 0.1 increments. Ignition does not currently model bounce.","title":"Comparison"},{"location":"tests/friction/","text":"Friction Friction is the resistance to motion of one object moving relative to another. There are several different types of friction that you can model. Here we are modeling kinetic friction by setting the coefficient of friction. The coefficient of friction in version 1.7 of the sdformat is modeled as an ODE parameter with mu as the coefficient for the \u201cfirst friction direction\u201d and mu2 as the coefficient for the \u201csecond friction direction\u201d. There is an additional parameter, fdir1 that can specify a specific primary friction direction relative to the link, otherwise it is modeled relative to the world. These two directions get modeled together using a simplified friction pyramid model. Example code snippet <link> ... <collision name= \"${name}_collision\" > ... <surface> <friction> <ode> <mu> 1 </mu> <mu2> 1 </mu2> <fdir1> 1 0 0 </fdir1> </ode> </friction> </surface> </collision> </link> Comparison From left to right: Cube1: Default friction. sdformat states that if no friction is set, mu1 and mu2 are set to 1 (high friction). Therefore, this cube shouldn't move. Cube2: mu=1 , mu2=0 . The ramp is pointed down the X axis. Therefore, I expect that with a high mu along that axis, the cube will not move Cube3: mu=0 , mu2=1 . The ramp is pointed down the X axis. Therefore, I expect that with no friction along this direction, the cube will move down the ramp. Cube4: mu=1 , mu2=0 , fdir1=1 0 0 (pointed down the ramp). Since the mu value is aligned with the ramp, I expect the block to stay still. Cube5: mu=1 , mu2=0 , fdir1=0 1 0 (pointed toward the sides of the ramp). Since the mu value is perpendicular to the ramp, I expect the block to move. Cube6: mu=1 , mu2=0 , fdir1=0 0 1 (pointed up). Since the mu value is perpendicular to the ramp, I expect the block to move. Cube7: Cube4, rotated along the Y-axis Since the mu value is rotated to be perpendicular to the ramp, I expect the block to move. Cube8: mu=1 rotated along the X-axis. Since only setting mu should set both values, the rotation shouldn't matter and the block shouldn't move. Cube9: mu=1 rotated along the X and Y-axis. Since only setting mu should set both values, the rotation shouldn't matter and the block shouldn't move. Notably, neither behaved quite how I was expecting. In Gazebo, the mu and mu2 arguments acted on the opposite axis as I expected, with the world y frame corresponding to mu and the world x frame corresponding to mu2. In Ignition, the mu and mu2 arguments act on the axis that I expected, with x corresponding to mu and y corresponding to mu2. However, setting the fdir1 direction to orientations perpendicular to the ramp direction incorrectly makes the box stay on the ramp.","title":"Friction"},{"location":"tests/friction/#friction","text":"Friction is the resistance to motion of one object moving relative to another. There are several different types of friction that you can model. Here we are modeling kinetic friction by setting the coefficient of friction. The coefficient of friction in version 1.7 of the sdformat is modeled as an ODE parameter with mu as the coefficient for the \u201cfirst friction direction\u201d and mu2 as the coefficient for the \u201csecond friction direction\u201d. There is an additional parameter, fdir1 that can specify a specific primary friction direction relative to the link, otherwise it is modeled relative to the world. These two directions get modeled together using a simplified friction pyramid model.","title":"Friction"},{"location":"tests/friction/#example-code-snippet","text":"<link> ... <collision name= \"${name}_collision\" > ... <surface> <friction> <ode> <mu> 1 </mu> <mu2> 1 </mu2> <fdir1> 1 0 0 </fdir1> </ode> </friction> </surface> </collision> </link>","title":"Example code snippet"},{"location":"tests/friction/#comparison","text":"From left to right: Cube1: Default friction. sdformat states that if no friction is set, mu1 and mu2 are set to 1 (high friction). Therefore, this cube shouldn't move. Cube2: mu=1 , mu2=0 . The ramp is pointed down the X axis. Therefore, I expect that with a high mu along that axis, the cube will not move Cube3: mu=0 , mu2=1 . The ramp is pointed down the X axis. Therefore, I expect that with no friction along this direction, the cube will move down the ramp. Cube4: mu=1 , mu2=0 , fdir1=1 0 0 (pointed down the ramp). Since the mu value is aligned with the ramp, I expect the block to stay still. Cube5: mu=1 , mu2=0 , fdir1=0 1 0 (pointed toward the sides of the ramp). Since the mu value is perpendicular to the ramp, I expect the block to move. Cube6: mu=1 , mu2=0 , fdir1=0 0 1 (pointed up). Since the mu value is perpendicular to the ramp, I expect the block to move. Cube7: Cube4, rotated along the Y-axis Since the mu value is rotated to be perpendicular to the ramp, I expect the block to move. Cube8: mu=1 rotated along the X-axis. Since only setting mu should set both values, the rotation shouldn't matter and the block shouldn't move. Cube9: mu=1 rotated along the X and Y-axis. Since only setting mu should set both values, the rotation shouldn't matter and the block shouldn't move. Notably, neither behaved quite how I was expecting. In Gazebo, the mu and mu2 arguments acted on the opposite axis as I expected, with the world y frame corresponding to mu and the world x frame corresponding to mu2. In Ignition, the mu and mu2 arguments act on the axis that I expected, with x corresponding to mu and y corresponding to mu2. However, setting the fdir1 direction to orientations perpendicular to the ramp direction incorrectly makes the box stay on the ramp.","title":"Comparison"},{"location":"tests/friction-pyramid/","text":"Friction Pyramid Both Gazebo and Ignition use a friction pyramid approximation. During tests of friction I noticed that Gazebo and Ignition set the values differently in x and y when using the default world frame which is clearly shown below Also of note is that while the ignition simulation produces much smoother results, it comes at a cost to the real-time factor.","title":"Friction Pyramid"},{"location":"tests/friction-pyramid/#friction-pyramid","text":"Both Gazebo and Ignition use a friction pyramid approximation. During tests of friction I noticed that Gazebo and Ignition set the values differently in x and y when using the default world frame which is clearly shown below Also of note is that while the ignition simulation produces much smoother results, it comes at a cost to the real-time factor.","title":"Friction Pyramid"},{"location":"tests/inertia/","text":"Inertia Inertia is the resistance of any physical object to any change in its velocity. It is an important element in simulation, as it lets the physics simulator calculate the correct dynamics of an object in simulation. From left to right: cube, solid sphere, hollow sphere, solid cylinder, hollow cylinder. All shapes have the same mass and are modeled with high friction. The high friction causes the cube to stay in place, while the other shapes are able to roll down the ramp as expected. Both Ignition and Gazebo work as expected.","title":"Inertia"},{"location":"tests/inertia/#inertia","text":"Inertia is the resistance of any physical object to any change in its velocity. It is an important element in simulation, as it lets the physics simulator calculate the correct dynamics of an object in simulation. From left to right: cube, solid sphere, hollow sphere, solid cylinder, hollow cylinder. All shapes have the same mass and are modeled with high friction. The high friction causes the cube to stay in place, while the other shapes are able to roll down the ramp as expected. Both Ignition and Gazebo work as expected.","title":"Inertia"},{"location":"tests/wheel-drift/","text":"Wheel drift Almost all robot configurations will cause the simulator to have numerical integration errors. Example errors from simple two-wheel robots. Example errors from simple four-wheel robots","title":"Wheel drift"},{"location":"tests/wheel-drift/#wheel-drift","text":"Almost all robot configurations will cause the simulator to have numerical integration errors. Example errors from simple two-wheel robots. Example errors from simple four-wheel robots","title":"Wheel drift"}]}